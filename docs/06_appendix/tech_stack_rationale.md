# Appendix: Technology Stack Rationale

This appendix provides the reasoning behind the key technology choices for the FinDocAI prototype.

| Technology | Rationale | Alternatives Considered |
| :--- | :--- | :--- |
| **FastAPI** | Selected for its high performance, native `async` support, and automatic generation of interactive API documentation (via Swagger UI). Its use of modern Python 3.10+ features and Pydantic for data validation makes it ideal for building robust, type-safe APIs. | **Flask** (considered too basic, lacks native async and data validation), **Django** (considered overkill for a microservice-oriented architecture). |
| **Celery** | The de facto standard for distributed task queues in the Python ecosystem. It is battle-tested, highly scalable, and features a rich ecosystem with excellent monitoring and management tools. Its support for Redis as a broker makes it easy to set up. | **Dramatiq** (a simpler alternative, but with a smaller community and less mature ecosystem), **RQ (Redis Queue)** (simpler than Celery but less feature-rich). |
| **PostgreSQL** | Chosen as the primary metadata store for its robustness, ACID compliance, JSON support, and excellent performance in handling concurrent operations. PostgreSQL's advanced features and mature ecosystem make it a solid choice for production environments. | **SQLite** (considered for its simplicity, but lacks concurrent access support which is needed for async processing), **MongoDB** (good for document storage but not optimal for structured metadata queries). |
| **Chroma DB** | Selected for its simplicity and ease of use in a local development environment. As an in-process, file-system-based vector store, it requires zero setup and is perfect for rapid prototyping of RAG pipelines. | **Pinecone** (requires a cloud subscription and network access), **Weaviate** (more powerful with features like GraphQL, but also more complex to set up and manage). |
| **Prometheus** | The industry standard for metrics collection and monitoring. Its pull-based model is simple to configure, and its query language (PromQL) is powerful. The wide adoption ensures excellent integration with tools like Grafana. | **CloudWatch** (a great choice for production on AWS, but using Prometheus for the demo avoids vendor lock-in and is more portable). |
| **Pydantic** | Used for data validation and settings management. It provides a crucial layer of type safety and structure, especially when dealing with unpredictable LLM outputs. Its integration with FastAPI is seamless. | Writing manual validation logic (brittle, error-prone, and time-consuming). |
