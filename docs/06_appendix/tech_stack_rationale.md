# Appendix: Technology Stack Rationale

This appendix provides the reasoning behind the key technology choices for the FinDocAI prototype.

| Technology | Rationale | Alternatives Considered |
| :--- | :--- | :--- |
| **FastAPI** | Selected for its high performance, native `async` support, and automatic generation of interactive API documentation (via Swagger UI). Its use of modern Python 3.10+ features and Pydantic for data validation makes it ideal for building robust, type-safe APIs. | **Flask** (considered too basic, lacks native async and data validation), **Django** (considered overkill for a microservice-oriented architecture). |
| **Celery** | The de facto standard for distributed task queues in the Python ecosystem. It is battle-tested, highly scalable, and features a rich ecosystem with excellent monitoring and management tools. Its support for Redis as a broker makes it easy to set up. | **Dramatiq** (a simpler alternative, but with a smaller community and less mature ecosystem), **RQ (Redis Queue)** (simpler than Celery but less feature-rich). |
| **Gemini API** | Chosen for its generous free tier, fast performance (especially the `gemini-1.5-flash` model), and strong capabilities in following structured JSON output instructions. It provides a great balance of cost, speed, and quality for prototyping. | **GPT-4** (more powerful but significantly more expensive), **Claude 3** (excellent capabilities but no free tier for API access at the time of development). |
| **Chroma DB** | Selected for its simplicity and ease of use in a local development environment. As an in-process, file-system-based vector store, it requires zero setup and is perfect for rapid prototyping of RAG pipelines. | **Pinecone** (requires a cloud subscription and network access), **Weaviate** (more powerful with features like GraphQL, but also more complex to set up and manage). |
| **Prometheus** | The industry standard for metrics collection and monitoring. Its pull-based model is simple to configure, and its query language (PromQL) is powerful. The wide adoption ensures excellent integration with tools like Grafana. | **CloudWatch** (a great choice for production on AWS, but using Prometheus for the demo avoids vendor lock-in and is more portable). |
| **Pydantic** | Used for data validation and settings management. It provides a crucial layer of type safety and structure, especially when dealing with unpredictable LLM outputs. Its integration with FastAPI is seamless. | Writing manual validation logic (brittle, error-prone, and time-consuming). |
